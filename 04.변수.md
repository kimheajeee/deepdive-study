# 4. 변수
## 4.1 변수란 무엇인가? 왜 필요한가?
```js
10 + 20
```
- 자바스크립트 엔진이 위 자바스크립트 코드를 계산(평가)하려면 먼저 10, 20, + 라는 기호(리터럴과 연산자)의 의미를 알고 있어야 하며, 10 + 20 이라는 식(표현식)의 의미도 해석(파싱)할 수 있어야 한다. 
- 연산을 수행하기 위해 좌변과 우변의 숫자 즉, 피연산자를 기억한다. 컴퓨터는 메모리를 사용해 데이터를 기억하고 cpu를 사용해 연산한다. 
- 메모리는 데이터를 저장할 수 있는 메모리 셀의 집합체이고, 메모리 셀 하나의 크기는 1바이트(8비트)이며, 컴퓨터는 메모리 셀 크기 단위로 데이터를 저장하거나 읽어들인다. 
- 각 셀은 고유의 메모리 주소를 갖는데, 이 메모리 주소는 메모리 공간의 위치를 나타낸다. 
> 즉, 위의 10 + 20 을 계산하기 위해 컴퓨터는 10과 20인 피연산자를 메모리 셀에 저장하고, cpu로 연산한 뒤, 결과값인 30을 메모리 셀 안에 저장한다. 
- 메모리 셀에 저장된 값을 사용하기 위해서는 메모리 공간에 접근을 해야하는데, 메모리 주소를 통해 직접 접근하는 것은 허용되지 않는다. 
- 대신 값의 위치를 가리키는 상징적인 이름인 '변수'를 통해 접근한다. 
> 즉, 변수(variable)란 '하나의 값을 저장하기 위해 확보한 메모리 공간 자체 또는 그 메모리 공간을 식별하기 위해 붙인 이름'이다. 

## 4.2 식별자
- 식별자 : 어떤 값을 구별해서 식별할 수 있는 고유한 이름
- 식별자는 변수 값을 저장하는 것이 아니라, 값이 저장된 메모리 주소를 기억한다. 
- 즉, 식별자와 메모리 주소는 매핑 관계를 맺고 있고, 이 매핑 정보도 메모리에 저장된다. 
- 변수, 함수, 클래스 등의 이름은 모두 식별자이며, **'선언'** 에 의해 자바스크립트 엔진에 식별자의 존재를 알린다. 

## 4.3 변수 선언
- 변수 선언이란 변수를 생성하는 것을 말한다. 
- 이를 좀 더 자세히 말하자면, 
> 값을 저장하기 위한 메모리 공간을 확보하고, 변수 이름과 확보된 메모리 공간의 주소를 연결(name biding)헤서 값을 저장할 수 있게 저장하는 것
- 변수 선언에는 `var, let, const` 키워드를 사용한다. es6에서 let, const의 도입이 있기 전에는 var가 유일한 변수 선언 키워드였다. var는 블록 레벨 스코프를 지원하지 않고 함수 레벨 스코프를 지원한다는 점에서 의도치 않은 부작용을 발생하기도 한다. 

- 자바스크립트 엔진은 변수 선언을 '선언 단계'와 '초기화 단계'로 나누어 수행한다. 
- 선언 단계 : 변수 이름을 등록해서 자바스크립트 엔진에 변수의 존재를 알린다. 
- 초기화 단계 : 값을 저장하기 위한 메모리 공간을 확보하고 암묵적으로 undefined를 할당한다. 초기화란 변수가 선언된 이후로 최초로 값을 할당하는 것을 말한다. 

var 키워드의 경우 선언 단계와 초기화 단계가 동시에 진행된다. 
```js
var score; //변수 선언(변수 선언문)
```
- 선언 단계를 통해 변수 이름 score를 등록하고, 초기화 단계를 통해 score 변수에 암묵적으로 undefined를 할당해 초기화 한다. 
- 변수를 선언한 후 변수에 값을 할당하지 않으면 자바스크립트 엔진에 의해 undefined라는 값이 암묵적으로 할당된다.
- 초기화 단계를 거치지 않으면 확보된 메모리 공간에 이전에 사용했던 값인 쓰레기 값(garbage value)가 남아있을 수도 있다. 
- 변수뿐만 아니라 모든 식별자(함수, 클래스 등)도 반드시 선언이 필요하고, 선언하지 않은 식별자에 접근하면 ReferenceError(참조에러)가 발생한다. 

## 4.4 변수 선언의 실행 시점과 변수 호이스팅
호이스팅이란 변수 선언문이 코드의 선두로 끌어 올려진 것처럼 동작하는 JS의 고유의 기능이다. 
```js
console.log(score); //undefined

var score;
```
- 변수를 참조하는 코드가 변수 선언문보다 앞에있지만 참조 에러가 발생하지 않고 undefined 가 출력된다. 
- 이는 변수 선언이 런타임(소스 코드가 한 줄씩 순차적으로 실행되는 시점) 이전에 '소스코드 평가 과정'에서 먼저 실행하기 때문이다. 
- 소스코드 평과 과정에서는 자바스크립트 엔진이 변수 선언을 포함한 모든 선언문(변수 선언문, 함수 선언문 등)을 소스코드에서 찾아내 먼저 실행한다. 
- 소스코드 평가 과정이 끝난 뒤 선언문을 제외한 소스코드를 한 줄씩 순차적으로 실행한다. 

## 4.5 값의 할당
할당 연산자 : `=`
- 우변의 값을 좌변의 변수에 할당하는 기능
- 변수 선언은 런타임 이전에 실행하지만 값의 할당은 런타임에 실행된다.
```js
console.log(score); //undefined

var score;
score = 80;

console.log(score); //80
```

<img src="https://user-images.githubusercontent.com/89509857/212057554-95c0ac2c-6760-4319-97b4-dd289a92f4da.jpg" width="500">

- 변수에 값을 할당할 때는 이전 값 undefined가 저장되어 있던 메모리 공간을 지우고 그 메모리 공간에 할당 값(80)을 새롭게 저장하는 것이 아니라 새로운 메모리 공간을 확보하고 그곳에 할당 값을 저장한다.

## 4.6 값의 재할당
재할당이란 이미 값이 할당되어 있는 변수에 새로운 값을 또다시 할당하는 것을 말한다. 
- const 키워드는 재할당이 금지된다. 즉, 한 번만 할당이 가능하므로 const는 상수를 표현할 수 있다. 
- 처음 할당했을 때와 마찬가지로 새로운 메모리 공간을 확보하고 그 메모리 공간에 새로운 값을 저장한다. 
- 이전 값들 즉, 어떤 식별자와도 연결되어 있지 않은 값들은 불필요한 값들로 가비지 콜렉터에 의해 메모리에서 자동 해제된다. 하지만 언제 해제될지는 예측할 수 없다. 

> 🔍 가비지 콜렉터
<br> 가비지 콜렉터는 애플리케이션이 할당한 메모리 공간을 주기적으로 검사하여 더 이상 사용되지 안흔 메모리를 해제하는 기능을 말한다. 자바스크립트는 가비지 콜렉터를 내장하고 있는 매니지드(managed) 언어로서 가비지 콜렉터를 통해 메모리 누수(memory leak)를 방지한다. 

## 4.7 식별자 네이밍 규칙
식별자는 네이밍 규칙을 준수해야 한다. 
- `문자, 숫자, $(달러), _(언더스코어)` 를 제외한 나머지 특수문자는 포함할 수 없다. 
- 숫자로 시작하는 것은 허용되지 않는다.
- 예약어는 식별자로 사용할 수 없다. 

>🔍예약어(reserved word)
<br> 예약어는 프로그래밍 언어에서 사용되고 있거나 사용될 예정인 단어를 말한다. (await, break, case, catch, class, const, continue, debugger, default, else, false, new, null 등등)

- 유니코드를 허용하므로 한글, 일본어 사용 가능하지만 권장하지는 않는다.
- 변수 이름은 변수 존재 목적을 쉽게 이해할 수 있도록 의미를 명확히 표현해야 한다. 
- 대소문자를 구분한다. 

>🔍 네이밍 컨벤션
```js
//카멜 케이스(camelCase)
var firstName;

//스네이크 케이스(snak_case)
var first_name;

//파스칼 케이스(PascalCase)
var FirstName;

//헝가리안 케이스(typeHungarianCase)
var strFisrtName; //type + identifier
var $elem = document.getElementById('myId'); //DOM노드
var observable$ = fromEvent(document, 'click'); //RxJS 옵저버블
```
자바스크립트에서는 일반적으로 변수나 함수 이름에는 카멜 케이스, 생성자 함수와 클래스의 이름은 파스칼 케이스를 사용한다. 




